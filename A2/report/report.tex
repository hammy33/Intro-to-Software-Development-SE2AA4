\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Solution}
\author{Hamrish Saravanakumar}
\date{\today}

\begin {document}

\maketitle
This report discusses the testing phase for the implementation of Assignment 2, specifically the code coverage of \texttt{CiricleT.py}, \texttt{TriangleT.py}, \texttt{BodyT.py}, and \texttt{Scene.py}. The assignment specifications are critiqued and the discussion questions are answered.

\section{Testing of the Original Program}

The following assignment exposed students to using \texttt{pytest} in order to implement an effective \texttt{test\_driver.py} to verify the code coverage of the python files written. The assignment specification required the complete testing of the methods in the python files \texttt{CiricleT.py}, \texttt{TriangleT.py}, \texttt{BodyT.py}, and \texttt{Scene.py}. Every method, including the getters and setters were tested using pytest to assert the expected output compared to the output of the written python files. 
\newline
\newline
The \texttt{CircleT.py} file only has getter methods, so one test case was written to ensure that the CircleT class successfully gets the \texttt{cm\_x}, \texttt{cm\_y}, \texttt{mass} and \texttt{m\_inert} functions. It is important to note that assignment specification clearly stated that a \texttt{ValueError} should be raised for a radius or mass value that isn't greater than 0. For this reason, two additional test cases were written to test edge cases that should raise a ValueError before even compiling, due to invalid state variables. Out of these 6 test cases, all 6 were passed. 
The same test cases were written for \texttt{TriangleT.py}, except the ValueError should have been raised for a side length or mass value that isn't greater than 0. Out of these 6 test cases, all 6 were passed. 
\newpage
The first four test cases for \texttt{BodyT.py} were identical to the previous two python files, as the four getter methods were tested. However, the assignment specifications had two exceptions that required a \texttt{ValueError} to be raised. The BodyT class should not have created a BodyT member if the length of the sequences passed for the x coordinates of the center of mass, y coordinate of the center of mass, and mass of the body were not equal to one another. In addition, if at least one of the values in the sequence of masses was less than or equal to zero, a ValueError should also be raised. Two separate test cases were written to test these edge cases. Out of 6 written tests, all 6 passed.
\newline
\newline
The first six test cases for \texttt{Scene.py} test the setters and getters of the shape, the unbalanced forces and initial velocities using a Scene that is defined with state variables that would allow the Scene object to construct without any issues. The getters were tested by asserted the object of type Shape or tuple that would be expected to be outputted for each respective method. The setter methods were tested by changing a particular property of the Scene object, and using the getter method to assert the appropriate, newly changed object of type Shape or tuple that would be expected to be outputted for each respective method. Testing the \texttt{sim} function is not as straight forward, and I was unable to effectively implement a test case for this method. However, I attempted to assert the expected values for both outputs "t" and "wsol" in two separate test cases. This would have been done by using the relative error formula to determine whether the calculated solution was close enough to the expected solution in order to confidently claim that a test case has passed. In each case, the outputted sequence was compared to the expected output, and the two sequences were subtracted from one another. The max value of this sequence was taken, and divided by the max value of the expected solution in order to obtain a relative error value. If this value was less than a value denoted by epsilon, which was chosen to be $10^-5$, the two sequences are considered close enough to be equal, and thus the test case would pass. Therefore, out of the 6 test cases that were created with confidence, all 6 passed. For the two test cases that were created to test the \texttt{sim} function, both tests failed, but this was a result of not having a fully implemented test case rather than having any fault with the code itself.
\newline
\newline
Although \texttt{test\_driver.py} was not required to have test cases for \texttt{Plot.py}, it's validity was confirmed used the given \texttt{test\_expt} file by running \texttt{make test} and comparing the generated graph with the Figure 1 in the A2 tex file.

\section{Results of Testing Partner's Code}

The testing of the partner code was conducted by copying the \texttt{CiricleT.py}, \texttt{TriangleT.py}, \texttt{BodyT.py}, and \texttt{Scene.py} files over to the local src folder where my \texttt{Plot.py}, \texttt{Shape.py} and \texttt{test\_driver.py} were used in order to run similar automated testing using pytest. This method allowed me to simply run \texttt{make test} without having to modeify the \texttt{Makefile}. The test cases that my \texttt{test\_driver.py} ran were explained in Section 1 in order to provide as close to a 100\% code coverage as possible. After running \texttt{make test}, a graph that looked identical to the plot provided in the assignment specification was created. This was expected because \texttt{plot.py} was called upon through \texttt{test\_expt.py}. After this, pytest ran as expected without any preliminary errors, and passed 24 out of 26 cases. This was expected because the final 2 test cases for the sim method were not written correctly, as mentioned in Section 1. Upon examining the partner code, all of the test cases ran as expected because the code was implemented in an almost identical fashion. 
\newline
\newline
The testing was far more efficient for Assignment 2 when comparing this exercise to the testing conducted in Assignment 1. In order to examine why this was the case, it is important to differentiate between formal and natural language. A general MIS reduces the discrepancies by using formal language, specifically mathematical notation in order to define functions, variables, parameters, exceptions, etc. This was not the case in Assignment 1, as the assignment specifications were written in Natural Language. This leaves a lot of decisions up to the implementer of the code, which proved to be the case as there were many different possible implementations of the code in Assignment 1. Specifically, my partner and I had interpreted the specifications in A1 very differently, which is why the testing was not as straight forward. By implementing an MIS to specify the desired implementation, the discrepancies that may arise from user interpretation is reduced significantly, which makes the testing exercise much more straight forward.
\newpage

\section{Critique of Given Design Specification}

The given design specification enables the programmer to create modules for simulating the physics of a scene where a shape moves through 2D space. This was done through the use of a module interface specification (MIS), that prioritizes the use of formal language to provide the properties of the modules. This includes the functions, state variables, invariants, exceptions, assumptions, etc. The use of formal language is effective in reducing the number of discrepancies that an individual often experiences when forced with making implementation decisions. Despite the standard that a MIS written in formal language often establishes, reading a specification that utilizes mathematical notation to define functions is much more complicated than reading a specification that is written in natural language, which made the process of understanding the implementation of the code quite challenging. However, this can not be commented as a drawback of the specification, as the mathematical notation allows for a greater standardization when it comes to the implementation of these modules. \texttt{CircleT.py} and \texttt{TriangleT.py} allows for greater freedom in other classes. Specifically in \texttt{Scene.py}, a sequence of members of these data types is able to be created to be analyzed.
\newline
\newline
Despite the nature of the formal language used to create the module interface specification for this assignment, there are a few changes to the design that can be proposed as a means of improving the effectiveness of the specification. In regards to \texttt{Scene.py}, this module could have been implemented as an abstract object instead of an abstract data type. In this case, specific functions could have been defined using @staticmethod to define them on the class level rather than having calculations  within the \texttt{init} method to define the state variables. This would allow for functionality when it comes to each function, and can be implemented because there is no practical use of having multiple Scene objects, especially in the context of this assignment. In addition, with \texttt{Scene.py}, if the nsteps parameter is equal to 1, the method will throw a \texttt{ZeroDivisionError}. There was no exception listed in the specification for this case, nor was an assumption made for the value of nsteps. In order to improve this, the constructor should raise a \texttt{ValueError} when this is the case, rather than waiting for the \texttt{ZeroDivisionError} to occur. Additionally, the \texttt{Shape.py} module would serve more effectively as an abstract object rather than an interface. Although this module is used effectively by modules such as \texttt{TriangleT.py}, \texttt{CircleT.py}, and \texttt{BodyT.py}, defining \texttt{Shape.py} as an abstract object would have enabled the programmer to make use of inheritance of the Shape class in order to make use of python's object oriented programming capabilities. 
\newpage
The effectiveness of the specification can also be analyzed based on the interface's ability to provide the programmer checks for potential exceptions. The programmer should be able to check the exception themselves without having to raise it. This is not necessarily the case with the given specification. A majority of the exceptions are resolved by raising a \texttt{ValueError}, but this does not provide the programmer themselves to choose what they want to do if this exception is raised. It can be argued that \texttt{ValueError} may act as a check for the programmer. This is because it prevents an unexpected error to occur later on in the program. An example is if a \texttt{ValueError} is raised for a mass value of 0, a \texttt{DivisionByZero} error is prevented from occurring later on in the program. However, in order to improve the programmer's freedom to deal with such checks as they wish, the exception should have been stated, but it should have been up to the programmer to either implement a function that handles the exception, or to simply raise the appropriate error.
\newline
\newline
Finally, the quality criteria discussed in class can be used as a means of determining the quality of the specification. Based on the observations made regarding some of the needed improvements to the specification, the current implementation is not general because it doesn't allow for increased freedom of the user to implement methods to handle exceptions as they wish, and is not essential because the repetition of the methods used in \texttt{Shape.py} that are used in modules such as \texttt{TriangleT.py} and \texttt{CircleT.py} offers the same service in multiple ways. By separating the setter and getters in \texttt{Scene.py} the specification is minimal, and can also be considered opaque because local functions that are not necessarily needed for the implementation of the class themselves are defined as private methods. Overall, there are components in which the specification falls short in generality and essentiality, however the overall use of formal language throughout the MIS provided for an implementation that created standardization among all programmers.
\newpage

\section{Answers}

\begin{enumerate}[a)]

\item The purpose of unit tests are to examine the behaviour of the code in a meaningful was. Although an argument exists that states that testing the getter and setter methods are tedious and are not worth the time, it is important to consider the following claim: If it is possible for a developer to write the code incorrectly, it should be tested. Regardless of how elementary the implementation of such methods may be, there is still room for error that must be tested in order to guarantee 100\% code coverage. 

\item Two functions would need to be defined within the automated test case for both $F_x$ and $F_y$. These functions would return a value for the unbalanced forces in the x and y direction based on the value of the input of each function; t. For example, the function $F_x(t)$ would return 1 if the time is less than 5, or else it will return 0. Likewise, the function $F_y(t)$ could be defined such that -9.81 (the force of gravity) is returned if the time is less than 5, or will return 9.81 otherwise. The automated test of the getter method should assert that a tuple of the two valid forces are being returned from the calculated solution based on the value of t. The automated test of the setter method should change the input value of the time for each function, and use the getter method to assert that a tuple of the two new valid forces are being returned based on the newly set value of t. Although these test cases were not required to be implemented in the \texttt{test\_driver}, an example of how these test cases could be implemented as described previously can be found in this tester. 

\item In order to implement an effective automated test, it is required to have an expected solution, the calculated solution, and a means of comparing the two solutions to determine if they are equivalent. The \texttt{Plot.py} module utilizes \texttt{matplotlib} in order to display three unique graphs. Although a quantifiable output is not necessarily created from \texttt{Plot.py}, the documentation of \texttt{matplotlib} provides an effective means of extracting a calculated and expected solution. Using the line of code \texttt{plt.savefig("figurename.png")}, the graph can be saved as a file. If both the expected and calculated solutions of this test can be represented by a png file, comparing the two image files can simply be done by reading the two files, and asserting if the contents are equal.
\newpage
\item
\noindent close\_enough($x_\text{calc}$, $x_\text{true}$):
\begin{itemize}
\item output: $out := \frac{max(diff(x_\text{calc}, x_\text{true}))} {max( x_\text{true})} < \epsilon$
\item exception: ($\neg (max(x_\text{true}) \neq 0) \Rightarrow \text{ValueError} | \neg(|x_\text{calc}| = |x_\text{true}|) \Rightarrow \text{ValueError})$
\end{itemize}

Local Functions:
\newline
\newline
\noindent $\text{max}: \text{seq of } \mathbb{R} \rightarrow \mathbb{R}$\\
\noindent $\text{max}(xs) \equiv (a: \mathbb{R} | \exists a \in xs | (\forall b \in xs \cdot a \ge b))$\\

\noindent $\text{diff}: \text{seq of } \mathbb{R} \times \text{seq of } \mathbb{R}
\rightarrow \text{seq of } \mathbb{R}$\\
\noindent $\text{diff}(xs, ys) \equiv [i: \mathbb{R} | i \in [0..|xs|-1] : xs_i - ys_i$]\\

\item The given MIS enables the programmer to write a python program to simulate the physics of a scene where a shape moves through 2D space. Therefore, the properties of the measurements and formulas used throughout the specification must be valid in the real world where they are applied. The reason why exceptions existed for non positive dimensions and masses is because such properties would be invalid according to the laws of physics. In regards to the coordinate system that represents the center of mass, similar pre-existing theorems and laws can be referenced in order to decide whether there should be exceptions for negative coordinates. According to the properties of the Cartesian Coordinate system, an x value and y value defined as a coordinate can be any rational number. Therefore, there should not be an exception for negative coordinates, as this would unnecessarily prevent the programmer from working with cases of center of masses that would otherwise be valid in 2D space.

\item In constructing the TriangleT class using the \texttt{init} method, an exception is raised. Specifically, if the inputted side length or mass of the triangle are not greater than zero, a \texttt{ValueError} should be raised. This directly proves that the state invariant holds before the access program is even called. This is crucial, as it means that the constructor will not build a member of the TriangleT class unless the exception does not occur. Since the \texttt{init} method does in fact have a transition, it can be proved that the invariant is always satisfied based on the constructor itself. If a TriangleT is in fact instantiated, the properties defined by the state variables must hold. If the inputs and the state variables hold for the state invariant, then it is proven that the invariant will always hold based on the given specification.   
\newpage
\item 
\begin{lstlisting} 
import math
L = [math.sqrt(i) for i in range(5, 20) if i % 2] 
\end{lstlisting} 

\item 
\begin{lstlisting} 
def remove_uppercase(s):
   return ''.join(i for i in s if not i.isupper())
\end{lstlisting}

\item While abstraction reduces complexity by removing details that are irrelevant, generalization actually reduces the complexity by replacing multiple entities which perform similar functions with a single construct. For example, a system that manages team basketball statistics will have a lot of properties such as point differential, home wins, away wins, conference wins, etc. However, for the purpose of displaying the standings of the teams, only the number of games played, number of wins and number of losses are needed. This means that the team's stats were abstracted and only the properties that were required for the context of the application were needed. On the other hand, generalization will not aim to remove any detail, but instead to make functionality applicable to a more generic range of items. This allows for a generic system that is applicable to far more types. 

\item High coupling implies that the module knows an extensive amount about the inner working of other modules. This makes changes very difficult to coordinate between modules, thus making them brittle and fragile. For example, if Module A knows too much about Module B, changes to the internals of Module B may break functionality in Module A. This is why the high coupling case where a module is used by many other modules.

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for Shape.py}

\noindent \lstinputlisting{../src/Shape.py}

\newpage

\section{Code for CircleT.py}

\noindent \lstinputlisting{../src/CircleT.py}

\newpage

\section{Code for TriangleT.py}

\noindent \lstinputlisting{../src/TriangleT.py}

\newpage

\section{Code for BodyT.py}

\noindent \lstinputlisting{../src/BodyT.py}

\newpage

\section{Code for Scene.py}

\noindent \lstinputlisting{../src/Scene.py}

\newpage

\section{Code for Plot.py}

\noindent \lstinputlisting{../src/Plot.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's CircleT.py}

\noindent \lstinputlisting{../partner/CircleT.py}

\newpage

\section{Code for Partner's TriangleT.py}

\noindent \lstinputlisting{../partner/TriangleT.py}

\newpage

\section{Code for Partner's BodyT.py}

\noindent \lstinputlisting{../partner/BodyT.py}

\newpage

\section{Code for Partner's Scene.py}

\noindent \lstinputlisting{../partner/Scene.py}

\newpage

\end {document}
